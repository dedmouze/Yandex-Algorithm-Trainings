# 16A. Минимум на отрезке

<table>
  <tr>
  	<td>Ограничение времени</td>
  	<td>1 секунда</td>
  </tr>
  <tr>
  	<td>Ограничение памяти</td>
  	<td>64Mb</td>
  </tr>
  <tr>
  	<td>Ввод</td>
  	<td>стандартный ввод или input.txt</td>
  </tr>
  <tr>
  	<td>Вывод</td>
  	<td>стандартный вывод или output.txt</td>
  </tr>
</table>

---
Рассмотрим последовательность целых чисел длины *n*. По ней с шагом 1 двигается «окно» длины *k*, то есть сначала в «окне» видны первые *k* чисел, на следующем шаге в «окне» уже будут находиться *k* чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.

## Формат ввода

В первой строке входных данных содержатся два натуральных числа *n и k (n ≤ 150000, k ≤ 10000, k ≤ n)* – длины последовательности и «окна», соответственно. На следующей строке находятся *n* чисел – сама последовательность.

## Формат вывода

Выходые данные должны содержать *n - k + 1* строк – минимумы для каждого положения «окна».

## Пример

|Ввод|Вывод|
|---|---|
|7 3<br>1 3 2 4 5 3 1|1 2 2 3 1|

## Примечания

Обратите внимание, что решение с непосредственным подсчётом минимума для каждого положения окна не пройдёт по времени. Один из способов решить задачу – использовать контейнер C++ std::multiset или его аналог, чтобы хранить содержимое окна и быстро получать минимум. Подробнее об std::multiset читайте здесь: <http://en.cppreference.com/w/cpp/container/multiset>.
